name: Create Test & Coverage Issues

on:
  schedule:
    # Run daily at 8 AM UTC
    - cron: '0 8 * * *'
  workflow_dispatch:
    inputs:
      check_type:
        description: 'Type of test check'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - coverage
          - failing-tests
          - missing-tests

jobs:
  test-analysis:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        id: run-tests
        run: |
          echo "Running tests with coverage..."

          # Run tests and capture coverage
          npm test -- --coverage --watchAll=false --passWithNoTests || true

          # Check if coverage report exists
          if [ -f "coverage/coverage-summary.json" ]; then
            echo "coverage_exists=true" >> $GITHUB_OUTPUT
          fi

          echo "tests_complete=true" >> $GITHUB_OUTPUT

      - name: Analyze test coverage
        id: coverage-analysis
        if: ${{ steps.run-tests.outputs.coverage_exists == 'true' && (github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'coverage' || github.event_name != 'workflow_dispatch') }}
        run: |
          echo "Analyzing test coverage..."

          if [ -f "coverage/coverage-summary.json" ]; then
            # Extract coverage percentages
            TOTAL_COVERAGE=$(jq -r '.total.lines.pct' coverage/coverage-summary.json 2>/dev/null || echo "0")
            STATEMENT_COVERAGE=$(jq -r '.total.statements.pct' coverage/coverage-summary.json 2>/dev/null || echo "0")
            BRANCH_COVERAGE=$(jq -r '.total.branches.pct' coverage/coverage-summary.json 2>/dev/null || echo "0")
            FUNCTION_COVERAGE=$(jq -r '.total.functions.pct' coverage/coverage-summary.json 2>/dev/null || echo "0")

            echo "total_coverage=$TOTAL_COVERAGE" >> $GITHUB_OUTPUT
            echo "statement_coverage=$STATEMENT_COVERAGE" >> $GITHUB_OUTPUT
            echo "branch_coverage=$BRANCH_COVERAGE" >> $GITHUB_OUTPUT
            echo "function_coverage=$FUNCTION_COVERAGE" >> $GITHUB_OUTPUT
            echo "coverage_complete=true" >> $GITHUB_OUTPUT
          fi

      - name: Analyze test files
        id: test-analysis
        if: ${{ github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'missing-tests' || github.event_name != 'workflow_dispatch' }}
        run: |
          echo "Analyzing test coverage..."

          # Count source files
          SRC_FILES=$(find src/ -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | wc -l)

          # Count test files
          TEST_FILES=$(find src/ -name "*.test.js" -o -name "*.test.ts" -o -name "*.test.tsx" -o -name "*.spec.js" -o -name "*.spec.ts" -o -name "*.spec.tsx" | wc -l)

          # Find files without tests
          UNTESTED_FILES=$(find src/ -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | sed 's|src/||' | while read file; do
            base=$(basename "$file" .js)
            base=$(basename "$base" .ts)
            base=$(basename "$base" .tsx)
            base=$(basename "$base" .jsx)
            if [ ! -f "src/${base}.test.js" ] && [ ! -f "src/${base}.test.ts" ] && [ ! -f "src/${base}.test.tsx" ] && [ ! -f "src/${base}.spec.js" ] && [ ! -f "src/${base}.spec.ts" ] && [ ! -f "src/${base}.spec.tsx" ]; then
              echo "$file"
            fi
          done | wc -l)

          echo "src_files=$SRC_FILES" >> $GITHUB_OUTPUT
          echo "test_files=$TEST_FILES" >> $GITHUB_OUTPUT
          echo "untested_files=$UNTESTED_FILES" >> $GITHUB_OUTPUT
          echo "test_analysis_complete=true" >> $GITHUB_OUTPUT

      - name: Create test coverage issue
        if: ${{ steps.coverage-analysis.outputs.coverage_complete == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const totalCoverage = parseFloat('${{ steps.coverage-analysis.outputs.total_coverage }}');
            const statementCoverage = parseFloat('${{ steps.coverage-analysis.outputs.statement_coverage }}');
            const branchCoverage = parseFloat('${{ steps.coverage-analysis.outputs.branch_coverage }}');
            const functionCoverage = parseFloat('${{ steps.coverage-analysis.outputs.function_coverage }}');

            // Only create issue if coverage is below 80%
            if (totalCoverage >= 80) {
              console.log(`Test coverage is good: ${totalCoverage}%`);
              return;
            }

            // Check if coverage issue already exists
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['test-coverage', 'automated'],
              state: 'open'
            });

            if (existingIssues.data.length > 0) {
              console.log('Test coverage issue already exists');
              return;
            }

            const issueBody = `## ðŸ“Š Test Coverage Improvement Needed

            **Overall Coverage:** ${totalCoverage}%
            **Statement Coverage:** ${statementCoverage}%
            **Branch Coverage:** ${branchCoverage}%
            **Function Coverage:** ${functionCoverage}%
            **Last Updated:** ${new Date().toISOString().split('T')[0]}

            ### Coverage Status:
            ${totalCoverage < 50 ? 'ðŸ”´ **Critical:** Coverage is below 50%' :
              totalCoverage < 70 ? 'ðŸŸ¡ **Warning:** Coverage is below 70%' :
              'ðŸŸ¢ **Good:** Coverage is above 70% but can be improved'}

            ### Coverage Breakdown:
            - **Lines:** ${statementCoverage}% (code executed during tests)
            - **Functions:** ${functionCoverage}% (functions called during tests)
            - **Branches:** ${branchCoverage}% (if/else paths tested)

            ### Recommendations:
            1. **Identify untested code:** Review coverage report for red areas
            2. **Add unit tests:** Focus on critical business logic
            3. **Add integration tests:** Test component interactions
            4. **Add edge case tests:** Test error conditions and edge cases
            5. **Mock external dependencies:** Improve test isolation

            ### Next Steps:
            1. Review the coverage report in \`coverage/lcov-report/index.html\`
            2. Identify the most critical untested code
            3. Write tests for high-risk areas first
            4. Set up coverage thresholds in CI/CD
            5. Consider test coverage badges

            ### Commands to run:
            \`\`\`bash
            npm test -- --coverage
            npx serve coverage/lcov-report
            \`\`\`

            ---
            *This issue was automatically created by the test coverage analysis.*
            `;

            const priority = totalCoverage < 50 ? 'high' : totalCoverage < 70 ? 'medium' : 'low';
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ“Š Improve Test Coverage (${totalCoverage}%)`,
              body: issueBody,
              labels: ['test-coverage', 'automated', 'enhancement', priority]
            });

            console.log(`Created test coverage issue: ${issue.data.html_url}`);

      - name: Create missing tests issue
        if: ${{ steps.test-analysis.outputs.test_analysis_complete == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const srcFiles = parseInt('${{ steps.test-analysis.outputs.src_files }}');
            const testFiles = parseInt('${{ steps.test-analysis.outputs.test_files }}');
            const untestedFiles = parseInt('${{ steps.test-analysis.outputs.untested_files }}');

            const testRatio = srcFiles > 0 ? (testFiles / srcFiles) * 100 : 0;

            // Only create issue if there are untested files or low test ratio
            if (untestedFiles === 0 && testRatio >= 80) {
              console.log(`Test coverage is adequate: ${testRatio.toFixed(1)}%`);
              return;
            }

            // Check if missing tests issue already exists
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['missing-tests', 'automated'],
              state: 'open'
            });

            if (existingIssues.data.length > 0) {
              console.log('Missing tests issue already exists');
              return;
            }

            const issueBody = `## ðŸ§ª Missing Test Files

            **Source Files:** ${srcFiles}
            **Test Files:** ${testFiles}
            **Untested Files:** ${untestedFiles}
            **Test Ratio:** ${testRatio.toFixed(1)}%
            **Last Updated:** ${new Date().toISOString().split('T')[0]}

            ### Test Coverage Status:
            ${testRatio < 50 ? 'ðŸ”´ **Critical:** Less than 50% of files have tests' :
              testRatio < 70 ? 'ðŸŸ¡ **Warning:** Less than 70% of files have tests' :
              'ðŸŸ¢ **Good:** Most files have tests but some are missing'}

            ### Issues Found:
            - **Untested Files:** ${untestedFiles} source files without corresponding test files
            - **Test-to-Source Ratio:** ${testRatio.toFixed(1)}% (${testFiles}/${srcFiles})

            ### Recommendations:
            1. **Create test files** for all source files following naming convention:
               - \`Component.tsx\` â†’ \`Component.test.tsx\`
               - \`utils.js\` â†’ \`utils.test.js\`
            2. **Start with critical files:** Test core business logic first
            3. **Use testing best practices:** Arrange-Act-Assert pattern
            4. **Test edge cases:** Error conditions, empty states, etc.
            5. **Mock external dependencies:** APIs, databases, etc.

            ### Testing Framework:
            Based on your project structure, consider using:
            - **Jest** for unit tests
            - **React Testing Library** for component tests
            - **Vitest** as a faster alternative to Jest

            ### Next Steps:
            1. Identify the most critical untested files
            2. Create test files with basic test structure
            3. Write tests for the happy path first
            4. Add tests for error conditions
            5. Set up test automation in CI/CD

            ### Example test structure:
            \`\`\`typescript
            import { render, screen } from '@testing-library/react';
            import { MyComponent } from './MyComponent';

            describe('MyComponent', () => {
              it('renders correctly', () => {
                render(<MyComponent />);
                expect(screen.getByText('Hello')).toBeInTheDocument();
              });
            });
            \`\`\`

            ---
            *This issue was automatically created by the test file analysis.*
            `;

            const priority = untestedFiles > 10 || testRatio < 50 ? 'high' : untestedFiles > 5 || testRatio < 70 ? 'medium' : 'low';
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ§ª Add Missing Tests (${untestedFiles} files, ${testRatio.toFixed(1)}% coverage)`,
              body: issueBody,
              labels: ['missing-tests', 'automated', 'enhancement', priority]
            });

            console.log(`Created missing tests issue: ${issue.data.html_url}`);